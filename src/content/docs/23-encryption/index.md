---
title: 加密算法介绍
---

加密算法是计算机科学中重要的一部分，它用于保护数据免受未经授权的访问、篡改和破坏。加密算法是一种将明文（原始数据）转换为密文（加密后的数据）的过程，以保护数据免受未经授权的访问。加密算法通常分为对称加密和非对称加密两种类型。

1. 对称加密：对称加密算法使用相同的密钥进行加密和解密。


2. 非对称加密：非对称加密算法使用一对密钥，公钥用于加密数据，私钥用于解密数据。公钥和私钥通常被保存在加密系统中，只有持有私钥的用户才能解密数据。


## 填充

在加密过程中，填充（Padding）是为了确保明文数据的长度符合加密算法的块大小要求。不同的填充方式适用于不同的场景. 

### 1. **PKCS#7 填充**
这是最常见的填充方式之一，适用于大多数分组加密模式（如 CBC、ECB）。PKCS#7 填充会在数据的末尾添加一个或多个字节，每个字节的值表示需要添加的填充值的个数。

- **示例**：
  - 如果块大小为 8 字节，数据长度为 9 字节，则需要填充 7 个字节，填充值为 `07 07 07 07 07 07 07`。
  - 如果数据正好是块大小的整数倍，则会填充一个完整块，每个字节的值等于块大小。例如，如果数据长度为 16 字节（块大小为 8 字节），则填充 `08 08 08 08 08 08 08 08`。

### 2. **ANSI X.923 填充**
这种填充方式与 PKCS#7 类似，但不同的是填充字节除了最后一个字节，其他填充字节都是 `00`，最后一个字节表示填充的字节数。

- **示例**：
  - 如果块大小为 8 字节，数据长度为 9 字节，则填充 `00 00 00 00 00 00 00 07`。
  - 如果数据正好是块大小的整数倍，则填充 `00 00 00 00 00 00 00 08`。

### 3. **ISO/IEC 7816-4 填充**
ISO/IEC 7816-4 填充在数据的末尾添加一个 `0x80`，后面填充 `00` 直到数据长度符合块大小要求。

- **示例**：
  - 如果块大小为 8 字节，数据长度为 9 字节，则填充 `80 00 00 00 00 00 00 00`。
  - 如果数据正好是块大小的整数倍，则需要添加一个完整块 `80 00 00 00 00 00 00 00`。

### 4. **Zero Padding（零填充）**
这种填充方式在数据的末尾添加 `00`，直到数据长度符合块大小要求。零填充只适用于明文数据长度不是块大小倍数的情况，如果数据长度刚好是块大小的倍数，零填充无法区分填充字节和真实数据，因此使用时需谨慎。

- **示例**：
  - 如果块大小为 8 字节，数据长度为 9 字节，则填充 `00 00 00 00 00 00 00 00`。

### 5. **ISO 10126 填充**
ISO 10126 填充与 ANSI X.923 填充类似，填充字节除了最后一个字节，其他填充字节为随机值，最后一个字节表示填充的字节数。

- **示例**：
  - 如果块大小为 8 字节，数据长度为 9 字节，则填充 `5F 3C 7A 6E B2 91 D4 07`（假设随机值为前 7 个字节）。

### 6. **No Padding（不填充）**
在某些情况下，数据长度恰好是块大小的整数倍时，可以选择不进行填充。这种方式通常用于流加密算法或者处理数据块大小的算法中。

### 7. **自定义填充**
在某些特殊情况下，你可能需要定义自己的填充方式，具体逻辑由加密算法使用方决定。需要确保解密过程可以正确识别和去除填充。


## 加密模式
加密模式（Cipher Mode）是分组加密算法用于处理超过单个数据块的数据的方法。不同的加密模式对数据安全性和处理方式有不同的影响。以下是几种常见的加密模式：

### 1. **ECB（Electronic Codebook）模式**

#### ECB 模式的工作原理

在 ECB 模式中，明文数据被分割成固定大小的块（通常是 8 字节或 16 字节，具体取决于使用的加密算法）。每个块独立地被加密成密文块。如果相同的明文块在不同的位置出现，它们将被加密成相同的密文块。

##### 加密过程

1. **分块**：将明文数据分割成固定大小的块。如果最后一块不足块大小，则需要填充。
2. **加密**：每个块单独进行加密，使用相同的密钥。
3. **输出**：每个明文块对应一个密文块，密文块按顺序组合成完整的密文。

##### 示例

假设使用 8 字节（64 位）的分组加密算法（如 DES），并加密下面的明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 | Block 4 |
|   ABCD  |   EFGH  |   ABCD  |   EFGH  |
```

假设每个块为 4 个字符，且字符用来表示 8 字节的数据块。

使用 ECB 模式加密后，结果如下：

密文（Ciphertext）：
```
| Cipher 1 | Cipher 2 | Cipher 1 | Cipher 2 |
```

在此示例中，由于 `Block 1` 和 `Block 3` 是相同的，且 `Block 2` 和 `Block 4` 也是相同的，因此它们在加密后生成的密文块也是相同的。

#### ECB 的缺点

- **缺乏混淆**：相同的明文块总是会产生相同的密文块，容易被攻击者识别和利用。
- **不适合大多数应用场景**：由于它不能隐藏数据模式，ECB 模式通常只在非常小的数据块或对安全性要求不高的场景下使用。

#### 适用场景

- **小数据块**：如加密单个密钥或特定的固定长度数据。
- **对安全性要求不高的应用**：如测试或需要快速实现分组加密的场景。

### 2. **CBC（Cipher Block Chaining）模式**

#### CBC 模式的工作原理

在 CBC 模式中，每个明文块在加密之前都会与前一个密文块进行异或（XOR）操作。第一个明文块在加密之前与初始化向量（IV）进行异或操作。这个过程保证了相同的明文块在不同位置生成不同的密文块，从而提供更强的安全性。

##### 加密过程

1. **分块**：将明文数据分割成固定大小的块。如果最后一块不足块大小，则需要填充。
2. **初始化向量 (IV)**：选择一个与块大小相同的随机 IV。
3. **加密每个块**：
   - 第一个明文块与 IV 进行异或，然后对结果进行加密，生成第一个密文块。
   - 每个后续的明文块与前一个密文块进行异或，然后对结果进行加密，生成相应的密文块。
4. **输出**：密文块按顺序组合成完整的密文。

##### 示例

假设使用 8 字节（64 位）的分组加密算法（如 DES），并加密下面的明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 |
|   P1    |   P2    |   P3    |
```

初始化向量（IV）：
```
IV = 01010101
```

假设每个块为 4 个字符，且字符表示 8 字节的数据块。

加密过程如下：

1. **第一个块**：
   - `P1 XOR IV` = `X1`
   - `E(X1)` = `C1`
2. **第二个块**：
   - `P2 XOR C1` = `X2`
   - `E(X2)` = `C2`
3. **第三个块**：
   - `P3 XOR C2` = `X3`
   - `E(X3)` = `C3`

密文（Ciphertext）：
```
|  C1  |  C2  |  C3  |
```

##### 解密过程

解密过程与加密过程相反：

1. **分块**：将密文数据分割成块。
2. **解密每个块**：
   - 对第一个密文块 `C1` 进行解密得到 `X1`，然后 `X1 XOR IV` 还原出明文块 `P1`。
   - 对每个后续的密文块 `Cn` 进行解密得到 `Xn`，然后 `Xn XOR C(n-1)` 还原出明文块 `Pn`。
3. **去除填充**（如果有的话），得到原始明文。

#### CBC 的优点和缺点

- **优点**：
  - 提供了更强的安全性，隐藏了明文的模式。
  - 相同的明文块在不同位置将生成不同的密文块。

- **缺点**：
  - 需要一个随机且唯一的 IV。
  - 解密过程不能并行，因为每个密文块依赖于前一个块。

#### 适用场景

- **文件加密**：适合加密文件、消息或数据流。
- **网络通信**：用于需要保密和随机性的加密数据传输。

### 3. **CFB（Cipher Feedback）模式**
CFB（Cipher Feedback）模式是一种将分组加密算法转换为流加密算法的模式。它可以加密小于分组大小的数据块，因此适合处理流数据。下面是 CFB 模式的工作原理和示意说明。

#### CFB 模式的工作原理

在 CFB 模式中，加密过程从一个初始化向量（IV）开始。IV 首先通过加密算法加密，然后将其输出与明文块进行异或（XOR）运算，得到密文块。接下来的每个块依赖于前一个密文块进行加密。

CFB 模式的特点是加密和解密过程几乎相同，并且可以处理任意长度的数据（即使数据不是分组大小的倍数）。CFB 通常用于流式数据加密，如实时通信。

##### 加密过程

1. **初始化向量 (IV)**：选择一个与块大小相同的随机 IV。
2. **加密**：
   - 将 IV 加密，得到一个输出块。
   - 将输出块与明文块进行异或，得到密文块。
   - 将密文块作为下一个加密输入（“反馈”）进行处理，重复上述步骤，直到加密完成。

##### 示例

假设我们使用 8 字节（64 位）的分组加密算法，并要加密以下明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 |
|   P1    |   P2    |   P3    |
```

初始化向量（IV）：
```
IV = 01010101
```

加密过程如下：

1. **第一个块**：
   - `E(IV)` = `O1` （IV 加密后的输出）
   - `P1 XOR O1` = `C1` （与明文块进行异或运算得到密文块）
2. **第二个块**：
   - `E(C1)` = `O2` （前一个密文块加密后的输出）
   - `P2 XOR O2` = `C2` （与明文块进行异或运算得到密文块）
3. **第三个块**：
   - `E(C2)` = `O3` （前一个密文块加密后的输出）
   - `P3 XOR O3` = `C3` （与明文块进行异或运算得到密文块）

密文（Ciphertext）：
```
|  C1  |  C2  |  C3  |
```

##### 解密过程

解密过程与加密过程非常相似：

1. **初始化向量 (IV)**：从加密过程中的 IV 开始。
2. **解密**：
   - 将 IV 加密，得到一个输出块。
   - 将输出块与密文块进行异或，得到明文块。
   - 将密文块作为下一个解密输入（“反馈”）进行处理，重复上述步骤，直到解密完成。

解密过程中使用与加密相同的加密算法和密钥。

#### CFB 的优点和缺点

- **优点**：
  - 可以处理任意长度的数据流，适用于实时数据加密。
  - 加密和解密过程几乎相同，简化了实现。
  - 反馈机制确保不同的明文块即使内容相同，密文块也不同。

- **缺点**：
  - 加密和解密是顺序进行的，无法并行化处理。
  - 错误传播性：一个密文块的错误会影响解密后的多个明文块，但不会扩散到整个消息。

#### 适用场景

- **实时数据加密**：如网络通信、视频流加密。
- **需要流式处理的应用**：如加密动态生成的数据。

### 4. **OFB（Output Feedback）模式**
OFB（Output Feedback）模式是一种将分组加密算法转换为流加密算法的模式。与 CFB 类似，OFB 模式也可以加密小于分组大小的数据块。OFB 模式的特点是加密过程中的反馈输出仅依赖于初始向量（IV）和之前的加密结果，而与明文无关。

#### OFB 模式的工作原理

在 OFB 模式中，每一轮加密的输出（称为密钥流）与明文块进行异或（XOR）运算，生成密文块。OFB 模式的特点是它的加密和解密过程是完全对称的，解密时同样使用密钥流与密文块进行异或操作来还原明文。

##### 加密过程

1. **初始化向量 (IV)**：选择一个与块大小相同的随机 IV。
2. **生成密钥流**：
   - 将 IV 加密，得到一个密钥流块。
   - 将密钥流块与明文块进行异或，得到密文块。
   - 使用加密后的输出作为下一个输入，重复上述步骤，直到加密完成。

##### 示例

假设我们使用 8 字节（64 位）的分组加密算法，并要加密以下明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 |
|   P1    |   P2    |   P3    |
```

初始化向量（IV）：
```
IV = 01010101
```

加密过程如下：

1. **第一个块**：
   - `E(IV)` = `O1` （IV 加密后的输出作为密钥流）
   - `P1 XOR O1` = `C1` （与明文块进行异或运算得到密文块）
2. **第二个块**：
   - `E(O1)` = `O2` （前一个密钥流加密后的输出）
   - `P2 XOR O2` = `C2` （与明文块进行异或运算得到密文块）
3. **第三个块**：
   - `E(O2)` = `O3` （前一个密钥流加密后的输出）
   - `P3 XOR O3` = `C3` （与明文块进行异或运算得到密文块）

密文（Ciphertext）：
```
|  C1  |  C2  |  C3  |
```

在 OFB 模式下，密文块的生成与明文的内容无关，而是依赖于前一次加密的输出（密钥流）。这样，即使两个相同的明文块在不同的位置出现，它们也会生成不同的密文块。

##### 解密过程

解密过程与加密过程几乎相同：

1. **初始化向量 (IV)**：从加密过程中的 IV 开始。
2. **生成密钥流**：
   - 将 IV 加密，得到一个密钥流块。
   - 将密钥流块与密文块进行异或，得到明文块。
   - 使用加密后的输出作为下一个输入，重复上述步骤，直到解密完成。

因为 OFB 模式的加密和解密使用相同的密钥流生成过程，所以解密操作也是通过与密钥流异或来还原明文。

#### OFB 的优点和缺点

- **优点**：
  - 不会传播解密错误：一个密文位错误只会影响对应的明文位，不会影响到后续的明文块。
  - 可以处理任意长度的数据流，适用于实时数据加密。
  - 加密和解密过程完全对称，简化实现。

- **缺点**：
  - 由于密钥流完全依赖于初始 IV 和加密过程中的输出，因此 IV 的选择至关重要。如果 IV 重复使用，可能会导致安全问题。
  - 加密和解密过程不能并行化。

#### 适用场景

- **流式数据加密**：如网络通信、加密视频流或音频流。
- **高可靠性要求的应用**：由于错误不会传播，适用于对数据完整性要求较高的场景。

### 5. **CTR（Counter）模式**
CTR（Counter，计数器）模式是一种将分组加密算法转换为流加密算法的模式。CTR 模式通过使用一个计数器来生成密钥流，然后将密钥流与明文进行异或（XOR）运算来生成密文。CTR 模式具有并行处理能力，并且加密和解密过程相同，因此非常高效。

#### CTR 模式的工作原理

在 CTR 模式中，加密和解密的主要操作是生成密钥流，然后与明文或密文进行异或运算。密钥流的生成依赖于一个计数器值（通常是递增的）和一个初始值（nonce）。

##### 加密过程

1. **初始化值 (Nonce)**：选择一个与块大小相同的随机值，称为 nonce。
2. **生成计数器值**：计数器从某个初始值开始递增，计数器值与 nonce 组合形成输入块。
3. **生成密钥流**：
   - 使用加密算法对 nonce 和计数器的组合进行加密，生成密钥流块。
   - 将密钥流块与明文块进行异或，得到密文块。
   - 计数器递增，生成下一个密钥流块，直到加密完成。

##### 示例

假设我们使用 8 字节（64 位）的分组加密算法，并要加密以下明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 |
|   P1    |   P2    |   P3    |
```

初始化值（Nonce）：
```
Nonce = 01010101
```

加密过程如下：

1. **第一个块**：
   - `Counter 1 = Nonce || 1`（计数器值 1 也可能从0开始）
   - `E(Counter 1)` = `K1` （生成密钥流块）
   - `P1 XOR K1` = `C1` （与明文块进行异或运算得到密文块）
2. **第二个块**：
   - `Counter 2 = Nonce || 2`（计数器值 2）
   - `E(Counter 2)` = `K2` （生成密钥流块）
   - `P2 XOR K2` = `C2` （与明文块进行异或运算得到密文块）
3. **第三个块**：
   - `Counter 3 = Nonce || 3`（计数器值 3）
   - `E(Counter 3)` = `K3` （生成密钥流块）
   - `P3 XOR K3` = `C3` （与明文块进行异或运算得到密文块）

密文（Ciphertext）：
```
|  C1  |  C2  |  C3  |
```

##### 解密过程

解密过程与加密过程完全相同：

1. **使用相同的 Nonce 和计数器**：生成与加密相同的密钥流。
2. **解密**：
   - 将密钥流块与密文块进行异或，得到明文块。

解密步骤与加密步骤是对称的，使用相同的密钥流生成方法。

#### CTR 的优点和缺点

- **优点**：
  - 可以并行处理：由于每个计数器值是独立的，密钥流块的生成和加密可以并行进行，提高了处理速度。
  - 支持任意长度的数据：不需要填充操作。
  - 加密和解密过程完全对称，简化了实现。
  - 误差不会传播：一个密文位错误只会影响对应的明文位。

- **缺点**：
  - 计数器和 nonce 的唯一性至关重要，不能重复使用相同的计数器值，否则会严重影响安全性。
  - 如果计数器重复使用，攻击者可能通过重放攻击或已知密文攻击恢复明文。

#### 适用场景

- **高速数据加密**：如网络通信、磁盘加密和其他需要高性能的加密场景。
- **并行计算**：适用于需要并行处理的大规模数据加密任务。

### 6. **GCM（Galois/Counter Mode）模式**
GCM（Galois/Counter Mode）是一种结合了加密和认证功能的加密模式。GCM 基于 CTR（Counter）模式进行加密，并使用 Galois 字段进行消息认证码（MAC）的计算，从而提供了数据的保密性和完整性验证。

#### GCM 模式的工作原理

GCM 模式的加密过程主要分为两部分：

1. **加密部分**：使用 CTR 模式对明文进行加密，生成密文。
2. **认证部分**：使用 Galois 字段的运算来生成消息认证码（MAC），确保数据的完整性和真实性。

##### 加密过程

1. **初始化值 (Nonce)**：选择一个与块大小相同的随机值，称为 nonce（也称为 IV，初始化向量）。
2. **生成计数器值**：计数器从某个初始值开始递增，计数器值与 nonce 组合形成输入块。
3. **加密**：
   - 使用加密算法对计数器和 nonce 的组合进行加密，生成密钥流块。
   - 将密钥流块与明文块进行异或，得到密文块。
   - 计数器递增，生成下一个密钥流块，直到加密完成。
4. **生成认证标签**：
   - 将密文块、附加数据（可选），以及 nonce 通过 Galois 字段运算生成一个认证标签（Tag），用于数据完整性验证。

##### 示例

假设我们使用 8 字节（64 位）的分组加密算法，并要加密以下明文：

明文（Plaintext）：
```
| Block 1 | Block 2 | Block 3 |
|   P1    |   P2    |   P3    |
```

附加数据（Additional Authenticated Data，AAD）：
```
AAD = "header data"
```

初始化值（Nonce）：
```
Nonce = 01010101
```

加密过程如下：

1. **第一个块**：
   - `Counter 1 = Nonce || 1`（计数器值 1）
   - `E(Counter 1)` = `K1` （生成密钥流块）
   - `P1 XOR K1` = `C1` （与明文块进行异或运算得到密文块）
2. **第二个块**：
   - `Counter 2 = Nonce || 2`（计数器值 2）
   - `E(Counter 2)` = `K2` （生成密钥流块）
   - `P2 XOR K2` = `C2` （与明文块进行异或运算得到密文块）
3. **第三个块**：
   - `Counter 3 = Nonce || 3`（计数器值 3）
   - `E(Counter 3)` = `K3` （生成密钥流块）
   - `P3 XOR K3` = `C3` （与明文块进行异或运算得到密文块）

生成密文（Ciphertext）：
```
|  C1  |  C2  |  C3  |
```

4. **认证标签**：
   - 将密文 `C1 || C2 || C3`、附加数据 `AAD`、和 `Nonce` 通过 Galois 字段运算生成一个认证标签（Tag）。

##### 解密过程

解密过程与加密过程类似：

1. **使用相同的 Nonce 和计数器**：生成与加密相同的密钥流。
2. **解密**：
   - 将密钥流块与密文块进行异或，得到明文块。
3. **验证**：
   - 使用 Galois 字段运算生成的认证标签（Tag）验证密文和附加数据是否被篡改。

解密过程中，如果认证标签验证失败，则说明数据被篡改，解密结果不可信。

#### GCM 的优点和缺点

- **优点**：
  - 提供了加密和认证的双重功能，确保数据的保密性和完整性。
  - 支持并行计算，性能非常高，适合高性能需求的应用场景。
  - 可以处理任意长度的数据，灵活性高。

- **缺点**：
  - 需要确保 nonce 的唯一性，不能重复使用相同的 nonce，否则会影响安全性。
  - 实现稍复杂，因为涉及到加密和认证两部分。

#### 适用场景

- **高安全性需求的通信**：如网络协议（TLS、IPsec）中需要同时保护数据的保密性和完整性。
- **存储加密**：用于加密文件或磁盘数据，同时确保数据未被篡改。

### 7. **Belt CTR（Counter Mode）模式**

Belt CTR（Counter Mode）是俄罗斯加密标准 GOST R 34.13-2015 中的 CTR 模式实现之一。Belt CTR 是基于对称密钥块加密算法（如 Belt Block Cipher）的加密模式，用于将块加密算法转化为流加密算法。与常规 CTR 模式类似，Belt CTR 通过计数器与密钥的组合来生成密钥流，并将其与明文进行异或（XOR）操作以生成密文。

#### Belt CTR 模式的工作原理

1. **初始化向量（Nonce）**：选择一个固定的初始值（Nonce），与计数器结合生成输入块。
   
2. **计数器生成**：计数器从初始值开始递增，用于生成每个加密块的输入。

3. **生成密钥流**：将每个计数器值与密钥一起使用 Belt Block Cipher 进行加密，生成密钥流块。

4. **异或操作**：将生成的密钥流块与明文块进行异或，生成密文。

#### 具体步骤

1. **设置 Nonce 和计数器**：
   - Nonce 通常是一个固定值，计数器初始值一般为零。
   - Nonce 和计数器的组合构成输入块，每次加密操作都需要生成一个唯一的输入块。

2. **加密计数器值**：
   - 使用 Belt Block Cipher 对 Nonce 与计数器的组合进行加密，生成密钥流块。

3. **生成密文**：
   - 将密钥流块与明文进行异或，得到对应的密文块。

4. **计数器递增**：
   - 计数器递增，用于生成下一个密钥流块，直到整个明文被加密完成。

#### 示例

假设我们使用 Belt Block Cipher，并且有以下输入：

- **密钥（Key）**：假设为 `0x0102030405060708090A0B0C0D0E0F10`
- **Nonce**：`0x0000000000000000`
- **计数器初始值**：`0x0000000000000000`
- **明文**：`0x1122334455667788`

##### 加密过程

1. **生成第一个输入块**：
   - Nonce: `0x0000000000000000`
   - Counter: `0x0000000000000001`
   - Input block: `Nonce || Counter` = `0x00000000000000000000000000000001`

2. **加密生成密钥流块**：
   - 使用 Belt Block Cipher 加密上述输入块，生成密钥流块 `K1`。

3. **异或操作生成密文**：
   - `C1 = P1 XOR K1`
   - 明文 `P1 = 0x1122334455667788`
   - 假设生成的密钥流块 `K1 = 0x89ABCDEF01234567`
   - 密文 `C1 = 0x1122334455667788 XOR 0x89ABCDEF01234567` = `0x98AFED3E547532EF`

4. **生成下一个密钥流块**：
   - 计数器递增：`Counter = 0x0000000000000002`
   - 生成下一个输入块 `0x00000000000000000000000000000002`
   - 重复上述过程直到所有明文块被加密。

### 8. **PCBC（Propagating Cipher Block Chaining）模式**

Propagating Cipher Block Chaining（PCBC）是一种加密模式，是 Cipher Block Chaining（CBC）的变种。它与 CBC 模式类似，但在每个加密块的过程中会将前一个明文块和前一个密文块同时参与到当前块的加密操作中。这种设计使得在解密过程中，如果一个密文块被篡改，不仅会影响相应的明文块，还会影响随后的多个明文块。

#### PCBC 模式的工作原理

##### 加密过程

1. **初始化向量 (IV)**：选择一个与块大小相同的随机值，称为初始化向量（IV），用于加密第一个明文块。

2. **加密第一个块**：
   - 将第一个明文块与 IV 进行异或运算。
   - 将结果与初始密钥进行加密，生成第一个密文块。

3. **加密后续块**：
   - 每个后续的明文块都与前一个明文块和前一个密文块进行异或运算。
   - 将结果与初始密钥进行加密，生成当前的密文块。

##### 解密过程

1. **解密第一个块**：
   - 将第一个密文块解密后，与 IV 进行异或运算，得到第一个明文块。

2. **解密后续块**：
   - 对于每个后续的密文块，将其解密后与前一个明文块和前一个密文块进行异或运算，得到当前的明文块。

#### 示例

假设我们有以下输入数据：

- **明文（Plaintext）**：`P1, P2, P3`（分成多个块）
- **初始化向量（IV）**：`IV`
- **密钥（Key）**：`K`

#### 加密过程

1. **加密第一个块**：
   - `C1 = E(K, P1 ⊕ IV)`
   - 使用密钥 `K` 对 `P1 ⊕ IV` 进行加密，生成第一个密文块 `C1`。

2. **加密第二个块**：
   - `C2 = E(K, P2 ⊕ P1 ⊕ C1)`
   - 使用密钥 `K` 对 `P2 ⊕ P1 ⊕ C1` 进行加密，生成第二个密文块 `C2`。

3. **加密第三个块**：
   - `C3 = E(K, P3 ⊕ P2 ⊕ C2)`
   - 使用密钥 `K` 对 `P3 ⊕ P2 ⊕ C2` 进行加密，生成第三个密文块 `C3`。

#### PCBC 模式的优点和缺点

- **优点**：
  - 加密后的密文具有更强的雪崩效应（Avalanche Effect）：即使一个密文块被修改，解密时会影响多个后续块的结果。

- **缺点**：
  - 这种传播效应在某些场景下可能不是期望的行为，因为一个错误或篡改会导致大面积的解密失败。
  - 相比于 CBC 模式，PCBC 在实际应用中的使用较少，尤其是在需要抗错误传播的场景中。
